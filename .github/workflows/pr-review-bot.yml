name: PR Review Bot

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  pull-requests: write
  contents: read

jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Check for unverified commits
        id: verify-commits
        uses: actions/github-script@v7
        with:
          script: |
            const commits = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const unverified = commits.data.filter(c => !c.commit.verification?.verified);

            if (unverified.length > 0) {
              const list = unverified.map(c =>
                `- \`${c.sha.substring(0,7)}\` ${c.commit.message.split('\n')[0]} (${c.commit.author?.name || 'unknown'})`
              ).join('\n');

              core.setOutput('unverified', 'true');
              core.setOutput('unverified_list', list);
              core.setOutput('unverified_count', unverified.length);
            } else {
              core.setOutput('unverified', 'false');
            }

      - name: Run ESLint
        id: eslint
        continue-on-error: true
        run: |
          npm run lint 2>&1 | tee eslint-output.txt || true
          WARNINGS=$(grep -c "warning" eslint-output.txt || echo "0")
          ERRORS=$(grep -c "error" eslint-output.txt || echo "0")
          echo "warnings=$WARNINGS" >> $GITHUB_OUTPUT
          echo "errors=$ERRORS" >> $GITHUB_OUTPUT

      - name: Run TypeScript check
        id: typescript
        continue-on-error: true
        run: |
          npx tsc --noEmit 2>&1 | tee tsc-output.txt || true
          ERRORS=$(grep -c "error TS" tsc-output.txt || echo "0")
          echo "errors=$ERRORS" >> $GITHUB_OUTPUT

      - name: Security Audit
        id: audit
        continue-on-error: true
        run: |
          npm audit --json > audit-output.json 2>/dev/null || true
          HIGH=$(jq '.metadata.vulnerabilities.high // 0' audit-output.json)
          CRITICAL=$(jq '.metadata.vulnerabilities.critical // 0' audit-output.json)
          echo "high=$HIGH" >> $GITHUB_OUTPUT
          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT

      - name: Check for new TODOs/FIXMEs
        id: todos
        run: |
          git diff origin/${{ github.base_ref }}...HEAD -- '*.ts' | grep -E '^\+.*\b(TODO|FIXME|HACK|XXX)\b' | head -20 > new-todos.txt || true
          COUNT=$(wc -l < new-todos.txt | tr -d ' ')
          echo "count=$COUNT" >> $GITHUB_OUTPUT

      - name: Check commit message format
        id: commits-format
        uses: actions/github-script@v7
        with:
          script: |
            const conventionalPattern = /^(feat|fix|refactor|test|ci|docs|chore|perf|style|build|revert)(\(.+\))?: .+/;

            const commits = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const badCommits = commits.data.filter(c => {
              const firstLine = c.commit.message.split('\n')[0];
              return !conventionalPattern.test(firstLine);
            });

            if (badCommits.length > 0) {
              const list = badCommits.map(c =>
                `- \`${c.sha.substring(0,7)}\` ${c.commit.message.split('\n')[0]}`
              ).join('\n');

              core.setOutput('invalid', 'true');
              core.setOutput('invalid_list', list);
              core.setOutput('invalid_count', badCommits.length);
            } else {
              core.setOutput('invalid', 'false');
            }

      - name: Post PR comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const unverified = '${{ steps.verify-commits.outputs.unverified }}' === 'true';
            const unverifiedList = `${{ steps.verify-commits.outputs.unverified_list }}`;
            const unverifiedCount = '${{ steps.verify-commits.outputs.unverified_count }}';

            const eslintWarnings = parseInt('${{ steps.eslint.outputs.warnings }}') || 0;
            const eslintErrors = parseInt('${{ steps.eslint.outputs.errors }}') || 0;
            const tscErrors = parseInt('${{ steps.typescript.outputs.errors }}') || 0;

            const auditHigh = parseInt('${{ steps.audit.outputs.high }}') || 0;
            const auditCritical = parseInt('${{ steps.audit.outputs.critical }}') || 0;

            const todoCount = parseInt('${{ steps.todos.outputs.count }}') || 0;

            const invalidCommits = '${{ steps.commits-format.outputs.invalid }}' === 'true';
            const invalidList = `${{ steps.commits-format.outputs.invalid_list }}`;
            const invalidCount = '${{ steps.commits-format.outputs.invalid_count }}';

            let comments = [];

            // Unverified commits warning
            if (unverified) {
              comments.push(`## ‚ö†Ô∏è Unverified Commits (${unverifiedCount})

            The following commits are not signed/verified:

            ${unverifiedList}

            <details>
            <summary>How to sign commits</summary>

            \`\`\`bash
            # SSH signing (recommended)
            git config --global gpg.format ssh
            git config --global user.signingkey ~/.ssh/id_ed25519.pub
            git config --global commit.gpgsign true

            # Re-sign last commit
            git commit --amend -S --no-edit
            git push --force-with-lease
            \`\`\`
            </details>`);
            }

            // Invalid commit message format
            if (invalidCommits) {
              comments.push(`## ‚ö†Ô∏è Non-Conventional Commits (${invalidCount})

            The following commits don't follow conventional commit format:

            ${invalidList}

            Expected: \`type(scope): description\`
            Types: feat, fix, refactor, test, ci, docs, chore, perf, style, build, revert`);
            }

            // ESLint warnings
            if (eslintWarnings > 0 || eslintErrors > 0) {
              comments.push(`## ${eslintErrors > 0 ? '‚ùå' : '‚ö†Ô∏è'} ESLint: ${eslintErrors} errors, ${eslintWarnings} warnings`);
            }

            // TypeScript errors
            if (tscErrors > 0) {
              comments.push(`## ‚ùå TypeScript: ${tscErrors} errors`);
            }

            // Security audit
            if (auditCritical > 0 || auditHigh > 0) {
              comments.push(`## ${auditCritical > 0 ? '‚ùå' : '‚ö†Ô∏è'} Security: ${auditCritical} critical, ${auditHigh} high vulnerabilities`);
            }

            // New TODOs
            if (todoCount > 0) {
              let todoList = '';
              try {
                todoList = fs.readFileSync('new-todos.txt', 'utf8').trim();
              } catch (e) {}
              comments.push(`## ‚ÑπÔ∏è New TODOs/FIXMEs (${todoCount})

            \`\`\`diff
            ${todoList}
            \`\`\``);
            }

            // Only post if there are issues
            if (comments.length === 0) {
              console.log('No issues found, skipping comment');
              return;
            }

            const body = `# ü§ñ PR Review Bot

            ${comments.join('\n\n---\n\n')}

            ---
            <sub>This is an automated review. Please address the issues above.</sub>`;

            // Find existing bot comment
            const existingComments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = existingComments.data.find(c =>
              c.user?.type === 'Bot' && c.body?.includes('ü§ñ PR Review Bot')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }
